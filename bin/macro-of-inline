#!/usr/bin/env python

from macro_of_inline import cfg

import sys
import argparse

parser = argparse.ArgumentParser(version="0.9", description="C Preprocessor to translate inline functions to equivalent macros")
parser.add_argument("i", metavar="INFILE", help="input file. by default, already preprocessed (see --with-cpp)")
parser.add_argument("-o", metavar="OUTFILE", help="output (default:-)", default="-")
parser.add_argument("--with-cpp", nargs='?', help="without this flag, the input needs to be explicitly preprocessed. but with this flag, the input file will be implicitly preprocessed within this program. note that, the default mode works tricky thus it's not always work. it depends on how tedious the input file is. gcc mode is experimental and only for testing", const='--', choices=['--', 'gcc'])
parser.add_argument("-X", nargs="+", metavar="OPTIONS", help="[--with-cpp] extra options to preprocessor (e.g. _Ipath _DHOGE)", default=[])
parser.add_argument("-I", nargs="+", metavar="PATHS", help="[--with-cpp] add paths to search", default=[])
parser.add_argument("--record", nargs='?', metavar="DIR", help="record the tracks of code translation. specify a directory if you don't want to use the default directory (default:record-macro-of-inline)", const="record-macro-of-inline")
parser.add_argument("--macroize-static-funs", action='store_true', help="[deprecated] static functions, no matter they are with inline specifier, are to be macroized")

args = parser.parse_args()

cfg.t.macroize_static_funs = args.macroize_static_funs
cfg.t.additional_search_paths = args.I
cfg.t.extra_options = args.X

if args.with_cpp:
	cfg.t.with_cpp = True
	cfg.t.cpp_mode = args.with_cpp

if args.record:
	cfg.t.record_enabled = True
	cfg.t.record_dir = args.record

# rewrite_file module imports recorder module and
# recorder module shouldn't be imported before cfg.t is all set.
from macro_of_inline import rewrite
runner = rewrite.Main(args.i)
output_txt = runner.run()

if args.o == "-":
	sys.stdout.write(output_txt)
else:
	f = open(args.o, "w")
	f.write(output_txt)
	f.close()
