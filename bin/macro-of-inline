#!/usr/bin/env python

from macro_of_inline import cfg

import sys
import argparse

parser = argparse.ArgumentParser(version="0.9", description="C Preprocessor to translate inline functions to equivalent macros")
parser.add_argument("i", metavar="INFILE", help="input file (see --cross-build)")
parser.add_argument("-o", metavar="OUTFILE", help="output (default:-)", default="-")
parser.add_argument("-I", nargs="+", metavar="PATHS", help="add paths to search", default=[])
parser.add_argument("--cross-build", action='store_true', help="input file is by default preprocessed. but with this flag, the file will be implicitly preprocessed with fake_libc_include. note that, the way this mode works is really tricky thus it's not always guaranteed that this mode works. It depends on how sane the input file is")
parser.add_argument("--record", nargs='?', metavar="DIR", help="record the tracks of code translation. specify a directory if you don't want to use the default directory (default:record-macro-of-inline)", const="record-macro-of-inline")
parser.add_argument("--macroize-static-funs", action='store_true', help="[deprecated] static functions, no matter they are with inline specifier, are to be macroized")

args = parser.parse_args()

cfg.t.cross_build = args.cross_build
cfg.t.macroize_static_funs = args.macroize_static_funs
cfg.t.additional_search_paths = args.I

if args.record:
	cfg.t.record_enabled = True
	cfg.t.record_dir = args.record

# rewrite_file module imports recorder module and
# recorder module shouldn't be imported before cfg.t is all set.
from macro_of_inline import rewrite
runner = rewrite.Main(args.i)
output_txt = runner.run()

if args.o == "-":
	sys.stdout.write(output_txt)
else:
	f = open(args.o, "w")
	f.write(output_txt)
	f.close()
